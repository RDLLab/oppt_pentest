/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "oppt/plugin/Plugin.hpp"
#include <cmath>

using std::cout;
using std::endl;

namespace oppt {
class PentestProblemRewardPlugin : public RewardPlugin {
public:
  PentestProblemRewardPlugin() : RewardPlugin() {}

  virtual ~PentestProblemRewardPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual FloatType getReward(
      const PropagationResultSharedPtr &propagationResult) const override {

    float total_reward = 0.0;
    // Retrieve previous and next state (s') from the propagation result
    VectorFloat prevStateVec =
        propagationResult->previousState->as<VectorState>()->asVector();
    VectorFloat nextStateVec =
        propagationResult->nextState->as<VectorState>()->asVector();
    FloatType lastAction =
        propagationResult->action->as<DiscreteVectorAction>()->asVector()[0];

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(lastAction, TEST_ACTIONS::size, OS_STATES_INFO::size);

    if (ap.actionIdx == HACK_ACTIONS::EXPLOIT_MACHINE) {
      unsigned seed1 =
          std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator(seed1);
      std::uniform_real_distribution<double> distribution(0, 1);
      FloatType pDetection = (FloatType)distribution(generator);
      if (pDetection < generalOptions_->pDetectionRisk) {
        // The machine was detected
        total_reward += generalOptions_->detectionPenalty;
      }
    }

    int nMachineParams = generalOptions_->nMachineParams;
    for (int i = 0; i < generalOptions_->nMachines; i++) {
      int hacked_idx = (i + 1) * nMachineParams - 1;
      if (prevStateVec[hacked_idx] != nextStateVec[hacked_idx]) {
        total_reward += nextStateVec[hacked_idx] == HACKED
                            ? generalOptions_->hackReward
                            : nextStateVec[hacked_idx] == UNHACKABLE
                                  ? generalOptions_->unhackableReward
                                  : 0;
      }
    }
    total_reward += generalOptions_->stepPenalty;

    // Otherwise, apply a step penalty
    return total_reward;
  }

  virtual std::pair<FloatType, FloatType> getMinMaxReward() const override {
    return std::make_pair(generalOptions_->detectionPenalty,
                          generalOptions_->allHackedMachines);
  }

private:
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_REWARD_PLUGIN(PentestProblemRewardPlugin)

} // namespace oppt
