/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "oppt/plugin/Plugin.hpp"
#include <cmath>

using std::cout;
using std::endl;

namespace oppt {
class PentestProblemRewardPlugin : public RewardPlugin {
public:
  PentestProblemRewardPlugin() : RewardPlugin() {}

  virtual ~PentestProblemRewardPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual FloatType getReward(
      const PropagationResultSharedPtr &propagationResult) const override {

    float total_reward = 0.0;
    // Retrieve previous and next state (s') from the propagation result
    VectorFloat prevStateVec =
        propagationResult->previousState->as<VectorState>()->asVector();
    VectorFloat nextStateVec =
        propagationResult->nextState->as<VectorState>()->asVector();
    VectorFloat lastAction =
        propagationResult->action->as<DiscreteVectorAction>()->asVector();

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(lastAction, generalOptions_ -> nMachines);

    int nMachineParams = generalOptions_->nMachineParams;
    if (ap.actionIdx == HACK_ACTIONS::EXPLOIT_MACHINE) {
      int hacked_idx = (ap.machineIdx + 1) * nMachineParams - 1;
      HACK_STAT phs = (HACK_STAT) prevStateVec[hacked_idx];
      HACK_STAT nhs = (HACK_STAT) nextStateVec[hacked_idx];

      // H , H - nothing
      // N, H - reward
      // H, N - invalid state
      // N, N - Failed penalty
      if (phs == NOT_HACKED && nhs == NOT_HACKED) {
        // Failed attack
        total_reward += generalOptions_ -> failedHackPenalty;
      }
      else if (phs == NOT_HACKED && nhs == HACKED) {
        // Successful attack
        total_reward += generalOptions_ -> hackReward;
      } else if (phs == HACKED && nhs == HACKED) {
        // total_reward += generalOptions_ -> failedHackPenalty;
        // The machine was already hacked
      } else {
        std :: cerr << "Error in deteminining states" << std :: endl;
        exit(1);
      }
    }

    if (ap.actionIdx != NO_ACTION) {
      total_reward += generalOptions_->stepPenalty;
    }

    // Otherwise, apply a step penalty
    return total_reward;
  }

  virtual std::pair<FloatType, FloatType> getMinMaxReward() const override {
    return std::make_pair(generalOptions_->failedHackPenalty,
                          generalOptions_->hackReward);
  }

private:
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_REWARD_PLUGIN(PentestProblemRewardPlugin)

} // namespace oppt
