/** * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */

#ifndef _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_
#define _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_

#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "PentestProblemObservation.hpp"
#include "oppt/opptCore/Distribution.hpp"
#include "oppt/plugin/Plugin.hpp"

std::default_random_engine generator(65537);

namespace oppt {

class PentestProblemObservationPlugin : public ObservationPlugin {
public:
  PentestProblemObservationPlugin() : ObservationPlugin() {}

  virtual ~PentestProblemObservationPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    // Parse options files
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual ObservationResultSharedPtr
  getObservation(const ObservationRequest *observationRequest) const override {
    // Check if the listen action was executed
    // Container for the results information
    ObservationResultSharedPtr observationResult =
        std::make_shared<ObservationResult>();
    observationResult->state = observationRequest->currentState.get();
    observationResult->action = observationRequest->action;
    VectorFloat actionApplied =
        observationRequest->action->as<VectorAction>()->asVector();
    ActionSpaceDiscretizerParams ap = getDiscreteAction(actionApplied);

    // Retrieve state information from the observation request
    VectorFloat stateVector =
        observationRequest->currentState->as<VectorState>()->asVector();

    long observationInt = -1;

    // Initialize observable State
    VectorFloat observationVector = {-1};

    MachineState ms = getMachineState(
        stateVector, generalOptions_->nMachineParams, ap.machineIdx);

    std::uniform_real_distribution<FloatType> distributionSwitch(0, 1);
    FloatType p_incorrect_obs = distributionSwitch(generator);
    bool isCorrectObs = true;

    if (p_incorrect_obs < generalOptions_->observationNoise) {
      isCorrectObs = false;
    }

    switch (ap.actionIdx) {
      /*
      case NO_ACTION: {
        observationInt = NO_OBS;
        break;
      }
      */

    // TODO: The agent should track when it tried to hack the machine and
    // failed, and update it in heuristic Reason: If the reward is too low, then
    // scared, if the reward is too high then always
    case TEST_ACTIONS::DETECT_OS: {
      if (ms.osStatesInfo == OS_STATES_INFO::WIN_7 ||
          ms.osStatesInfo == OS_STATES_INFO::WIN_8) {
        observationInt = isCorrectObs ? WIN_OLD : WIN_NEW;
      } else {
        observationInt = isCorrectObs ? WIN_NEW : WIN_OLD;
      }
      break;
    }
    case TEST_ACTIONS::PROBE_P445: {
      observationInt = ms.portInfo == OPEN_445
                           ? (isCorrectObs ? OPEN_PORT_OBS : CLOSED_PORT_OBS)
                           : (isCorrectObs ? CLOSED_PORT_OBS : OPEN_PORT_OBS);
      break;
    }
    case HACK_ACTIONS::EXPLOIT_MACHINE: {
      observationInt = ms.hackStat == HACKED
                           ? (isCorrectObs ? AGENT_INSTALLED : NO_AGENT)
                           : (isCorrectObs ? NO_AGENT : AGENT_INSTALLED);
    }
    }

    // REVIEW: ALready hacked observation?
    observationVector[0] = observationInt;

    // Wrap the observation into the corresponding object
    observationResult->observation =
        std::make_shared<PentestProblemObservation>(observationVector);

    /*
    **
    observationResult->observation = ObservationSharedPtr(
        new DiscreteVectorObservation({(FloatType)(observationInt)}));

    observationResult->observation->as<DiscreteVectorObservation>()
        ->setBinNumber(observationInt);
     */

    // Add the observation error to the observationVector
    return observationResult;
  }

  virtual FloatType
  calcLikelihood(const RobotStateSharedPtr &state, const Action *action,
                 const Observation *observation) const override {

    VectorFloat stateVector = state->as<VectorState>()->asVector();

    PENTEST_OBSERVATIONS obs =
        (PENTEST_OBSERVATIONS)observation->as<VectorObservation>()
            ->asVector()[0];

    VectorFloat actionApplied = action->as<VectorAction>()->asVector();

    ActionSpaceDiscretizerParams ap = getDiscreteAction(actionApplied);

    MachineState ms = getMachineState(
        stateVector, generalOptions_->nMachineParams, ap.machineIdx);

    switch (ap.actionIdx) {
      /*
    case NO_ACTION: {
      return 1.0;
    }
    */
    case TEST_ACTIONS::DETECT_OS: {

      if (((ms.osStatesInfo == OS_STATES_INFO::WIN_7 ||
            ms.osStatesInfo == OS_STATES_INFO::WIN_8) &&
           obs == WIN_OLD) ||
          ((ms.osStatesInfo == OS_STATES_INFO::WIN_10 ||
            ms.osStatesInfo == OS_STATES_INFO::WIN_11) &&
           obs == WIN_NEW)) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    case TEST_ACTIONS::PROBE_P445: {
      if ((ms.portInfo == OPEN_445 && obs == OPEN_PORT_OBS) ||
          (ms.portInfo == CLOSED_PORT && obs == CLOSED_PORT_OBS)) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    case HACK_ACTIONS::EXPLOIT_MACHINE: {
      if ((ms.hackStat == NOT_HACKED && obs == NO_AGENT) ||
          (ms.hackStat == HACKED && (obs == AGENT_INSTALLED))) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    }
    return generalOptions_->observationNoise;
  }

private:
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_OBSERVATION_PLUGIN(PentestProblemObservationPlugin)

} // namespace oppt

#endif
