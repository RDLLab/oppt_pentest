/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */

#ifndef _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_
#define _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_

#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "PentestProblemObservation.hpp"
#include "oppt/opptCore/Distribution.hpp"
#include "oppt/plugin/Plugin.hpp"

std::default_random_engine generator(65537);

namespace oppt {

class PentestProblemObservationPlugin : public ObservationPlugin {
public:
  PentestProblemObservationPlugin() : ObservationPlugin() {}

  virtual ~PentestProblemObservationPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    // Parse options files
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual ObservationResultSharedPtr
  getObservation(const ObservationRequest *observationRequest) const override {
    // Check if the listen action was executed
    // Container for the results information
    ObservationResultSharedPtr observationResult =
        std::make_shared<ObservationResult>();
    observationResult->state = observationRequest->currentState.get();
    observationResult->action = observationRequest->action;
    VectorFloat actionApplied =
        observationRequest->action->as<VectorAction>()->asVector();

    // Retrieve state information from the observation request
    VectorFloat stateVector =
        observationRequest->currentState->as<VectorState>()->asVector();

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(actionApplied, generalOptions_->nMachines);

    long observationInt = -1;

    // Initialize observable State
    VectorFloat observationVector = {-1};

    int machineStateIdx = generalOptions_->nMachineParams * ap.machineIdx;

    std::uniform_real_distribution<FloatType> distributionSwitch(0, 1);
    FloatType p_incorrect_obs = distributionSwitch(generator);
    bool isCorrectObs = true;

    if (p_incorrect_obs < generalOptions_->observationNoise) {
      isCorrectObs = false;
    }

    switch (ap.actionIdx) {
      /*
      case NO_ACTION: {
        observationInt = NO_OBS;
        break;
      }
      */

    case TEST_ACTIONS::DETECT_OS: {
      if (stateVector[machineStateIdx] == OS_STATES_INFO::WIN_7 ||
          stateVector[machineStateIdx] == OS_STATES_INFO::WIN_8) {
        observationInt = isCorrectObs ? WIN_OLD : WIN_NEW;
      } else {
        observationInt = isCorrectObs ? WIN_NEW : WIN_OLD;
      }
      break;
    }
    case TEST_ACTIONS::PROBE_P445: {
      int portState = stateVector[machineStateIdx + 1];
      observationInt = portState == OPEN_445
                           ? (isCorrectObs ? OPEN_PORT_OBS : CLOSED_PORT_OBS)
                           : (isCorrectObs ? CLOSED_PORT_OBS : OPEN_PORT_OBS);
      break;
    }
    case HACK_ACTIONS::EXPLOIT_MACHINE: {
      int hackState = stateVector[machineStateIdx + 3];
      observationInt = hackState == NOT_HACKED
                           ? (isCorrectObs ? NO_AGENT : AGENT_INSTALLED)
                           : (isCorrectObs ? AGENT_INSTALLED : NO_AGENT);
    }
    }

    observationVector[0] = observationInt;

    // Wrap the observation into the corresponding object
    observationResult->observation =
        std::make_shared<PentestProblemObservation>(observationVector);

    /*
    **
    observationResult->observation = ObservationSharedPtr(
        new DiscreteVectorObservation({(FloatType)(observationInt)}));

    observationResult->observation->as<DiscreteVectorObservation>()
        ->setBinNumber(observationInt);
     */

    // Add the observation error to the observationVector
    return observationResult;
  }

  virtual FloatType
  calcLikelihood(const RobotStateSharedPtr &state, const Action *action,
                 const Observation *observation) const override {

    VectorFloat stateVector = state->as<VectorState>()->asVector();

    PENTEST_OBSERVATIONS obs =
        (PENTEST_OBSERVATIONS)observation->as<VectorObservation>()
            ->asVector()[0];
    VectorFloat actionApplied = action->as<VectorAction>()->asVector();

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(actionApplied, generalOptions_->nMachines);
    int machineStateIdx = generalOptions_->nMachineParams * ap.machineIdx;

    switch (ap.actionIdx) {
      /*
    case NO_ACTION: {
      return 1.0;
    }
    */
    case TEST_ACTIONS::DETECT_OS: {
      int osState = stateVector[machineStateIdx];

      if (((osState == OS_STATES_INFO::WIN_7 ||
            osState == OS_STATES_INFO::WIN_8) &&
           obs == WIN_OLD) ||
          ((osState == OS_STATES_INFO::WIN_10 ||
            osState == OS_STATES_INFO::WIN_11) &&
           obs == WIN_NEW)) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    case TEST_ACTIONS::PROBE_P445: {
      int portState = stateVector[machineStateIdx + 1];
      if ((portState == OPEN_445 && obs == OPEN_PORT_OBS) ||
          (portState == CLOSED_PORT && obs == CLOSED_PORT_OBS)) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    case HACK_ACTIONS::EXPLOIT_MACHINE: {
      int hackState = stateVector[machineStateIdx + 3];
      if ((hackState == NOT_HACKED && obs == NO_AGENT) ||
          (hackState == HACKED && (obs == AGENT_INSTALLED))) {
        return 1.0 - generalOptions_->observationNoise;
      }
      break;
    }
    }
    return generalOptions_->observationNoise;
  }

private:
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_OBSERVATION_PLUGIN(PentestProblemObservationPlugin)

} // namespace oppt

#endif
