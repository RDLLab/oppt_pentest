/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */

#ifndef _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_
#define _SKD_KAMIKAZE_OBSERVATION_PLUGIN_HPP_

#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "PentestProblemObservation.hpp"
#include "oppt/opptCore/Distribution.hpp"
#include "oppt/plugin/Plugin.hpp"

namespace oppt {

class PentestProblemObservationPlugin : public ObservationPlugin {
public:
  PentestProblemObservationPlugin() : ObservationPlugin() {}

  virtual ~PentestProblemObservationPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    // Parse options files
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual ObservationResultSharedPtr
  getObservation(const ObservationRequest *observationRequest) const override {
    // Check if the listen action was executed
    // Container for the results information
    ObservationResultSharedPtr observationResult =
        std::make_shared<ObservationResult>();
    observationResult->state = observationRequest->currentState.get();
    observationResult->action = observationRequest->action;
    VectorFloat actionApplied =
        observationRequest->action->as<VectorAction>()->asVector();


    // Retrieve state information from the observation request
    VectorFloat stateVector =
        observationRequest->currentState->as<VectorState>()->asVector();

    ActionSpaceDiscretizerParams ap = getDiscreteAction(
          actionApplied[0], TEST_ACTIONS::size, OS_STATES_INFO::size, generalOptions_ -> nMachines);

    int observationInt = 0;

    // Initialize observable State
    VectorFloat observationVector(1, 0);

    int machineStateIdx = generalOptions_->nMachineParams * ap.machineIdx;
    switch (ap.actionIdx) {
    case TEST_ACTIONS::DETECT_OS:
      if (stateVector[machineStateIdx] == OS_STATES_INFO::WIN_7 ||
          OS_STATES_INFO::WIN_8) {
        observationInt = WIN_OLD;
      } else {
        observationInt = WIN_NEW;
      }
      break;
    case TEST_ACTIONS::PROBE_P445:
      observationInt = CLOSED_PORT_OBS;
      if (stateVector[machineStateIdx + 1] == OPEN_445) {

        unsigned seed1 =
            std::chrono::system_clock::now().time_since_epoch().count();
        std::default_random_engine generator(seed1);
        std::uniform_real_distribution<double> distribution(0, 1);

        // Pack it into the oppt structures
        FloatType pHackSuccess = (FloatType)distribution(generator);
        if (pHackSuccess < 0.9) {
          observationInt = OPEN_445;
        }
      }

      break;
    case HACK_ACTIONS::EXPLOIT_MACHINE:
      int hackState = stateVector[machineStateIdx + 3];
      observationInt = hackState == NOT_HACKED ? NO_AGENT : AGENT_INSTALLED;
    }

    observationVector[0] = observationInt;

    // Wrap the observation into the corresponding object
    observationResult->observation =
        std::make_shared<PentestProblemObservation>(observationVector);

    // Add the observation error to the observationVector
    return observationResult;
  }

  virtual FloatType
  calcLikelihood(const RobotStateSharedPtr &state, const Action *action,
                 const Observation *observation) const override {
    // REVIEW: Is the nominal observation always 1.0?
    // If action was not listen. Return equal likelihood
    return 1.0;
  }

private:
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_OBSERVATION_PLUGIN(PentestProblemObservationPlugin)

} // namespace oppt

#endif
