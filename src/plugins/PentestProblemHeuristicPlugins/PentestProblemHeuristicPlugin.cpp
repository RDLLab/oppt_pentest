/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#ifndef _KAMIKAZE_TRAJ_GEN_HEURISTIC_PLUGIN_HPP_
#define _KAMIKAZE_TRAJ_GEN_HEURISTIC_PLUGIN_HPP_
#include "../PentestProblemTransitionPlugins/PentestProblemActionSpaceDiscretizer.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "oppt/plugin/Plugin.hpp"

namespace oppt {
class PentestProblemHeuristicPlugin : public HeuristicPlugin {
public:
  PentestProblemHeuristicPlugin() : HeuristicPlugin() {}

  virtual ~PentestProblemHeuristicPlugin() {}

  virtual bool load(const std::string &optionsFile) override {
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);

    // Retrieve pointer to options file
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    return true;
  }

  virtual FloatType
  getHeuristicValue(const HeuristicInfo *heuristicInfo) const override {

    // TODO: Get correct heuristic algorithm
    // Based on State and action, if you tried to attempt a hack action and the machine wasn't hacked, then return 0 else return 1
    /*
    VectorFloat stateVector =
        heuristicInfo->currentState->as<VectorState>()->asVector();

    VectorFloat lastAction = heuristicInfo->action->as<DiscreteVectorAction>()->asVector();

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(lastAction, generalOptions_ -> nMachines);

    int nMachineParams = generalOptions_->nMachineParams;
    if (ap.actionIdx == HACK_ACTIONS::EXPLOIT_MACHINE) {
      int hacked_idx = (ap.machineIdx + 1) * nMachineParams - 1;
      HACK_STAT hs = (HACK_STAT) stateVector[hacked_idx];

      if (hs == NOT_HACKED) {
        return 1.0 - generalOptions_ -> pSuccessfulHack;
      }
    }
    */

    /*
    VectorFloat stateVector =
        heuristicInfo->currentState->as<VectorState>()->asVector();

    FloatType currentDiscount = 1.0;
    FloatType totalDiscountedReward = 0;

    int nMachines = generalOptions_->nMachines;
    int notHackedMachines = 0;
    int nMachineParams = generalOptions_->nMachineParams;

    // Simulate hacking action for all machines
    for (int i = 0; i < nMachines; i++) {
      int machineStateIdx = i * nMachineParams;
      OS_STATES_INFO::Type currOs =
          (OS_STATES_INFO::Type)stateVector[machineStateIdx];
      PORT_INFO currPort = (PORT_INFO)stateVector[machineStateIdx + 1];
      SERVER_INFO currServer = (SERVER_INFO)stateVector[machineStateIdx + 2];
      HACK_STAT currHackStat = (HACK_STAT)stateVector[machineStateIdx + 3];
      if (currHackStat == NOT_HACKED &&currPort == OPEN_445 &&currServer ==
              OPEN_SAMBA_445 &&currOs != OS_STATES_INFO::WIN_11) {
        notHackedMachines++;
        currentDiscount *=
            std::pow(heuristicInfo->discountFactor, notHackedMachines);
        totalDiscountedReward += currentDiscount * generalOptions_->hackReward;
      }
    }
    */
    return 1.0;
  }

private:
  // Pointer to structure with parsed options values
  PentestProblemGeneralOptions *generalOptions_;
};

OPPT_REGISTER_HEURISTIC_PLUGIN(PentestProblemHeuristicPlugin)

} // namespace oppt

#endif
