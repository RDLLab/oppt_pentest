/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#ifndef _MAZE_PROBLEM_UTILS_HPP_
#define _MAZE_PROBLEM_UTILS_HPP_
#include "oppt/plugin/PluginOptions.hpp"

namespace oppt {

// DEFINE THE ENCODED VALUE FOR ACTIONS
enum MAZE_STATES_INFO { AGENT_X_INDEX = 0, AGENT_Y_INDEX = 1 };
enum MAZE_ACTIONS_INFO { MAZE_ACTION_INDEX = 0 };
// enum MAZE_STATES { MAZE_STATES = 0 };
enum MAZE_PROBLEM_ACTIONS {
  MOVE_LEFT = 0,
  MOVE_UP = 1,
  MOVE_RIGHT = 2,
  MOVE_DOWN = 3
};

// Options object to parse information from configuration file
class MazeProblemGeneralOptions : public PluginOptions {
public:
  MazeProblemGeneralOptions() = default;

  virtual ~MazeProblemGeneralOptions() = default;

  VectorFloat mazeDims;
  // Initial belief variables
  VectorFloat startPosition;
  VectorFloat winningPosition;
  VectorFloat losingPosition;

  // Reward variables
  FloatType winningStateReward = 0.0;
  FloatType losingStatePenalty = 0.0;
  FloatType stepPenalty = 0.0;
  std::vector<VectorFloat> rockPositions = {};

  // Transition variables

  // The probability of going to the correct direction, else it is distributed
  // equally going to the normal directions
  FloatType pCorrectDirection = 0.0;

  static std::unique_ptr<options::OptionParser> makeParser() {
    std::unique_ptr<options::OptionParser> parser = PluginOptions::makeParser();
    addGeneralPluginOptions(parser.get());
    return std::move(parser);
  }

  // Add the general plugin options
  static void addGeneralPluginOptions(options::OptionParser *parser) {

    parser->addOption<VectorFloat>("generalOptions", "mazeDims",
                                   &MazeProblemGeneralOptions::mazeDims);
    /*** Initial belief options ***/
    // Starting Position
    parser->addOption<VectorFloat>("initialBeliefOptions", "startPosition",
                                   &MazeProblemGeneralOptions::startPosition);
    // Winning Position
    parser->addOption<VectorFloat>("initialBeliefOptions", "winningPosition",
                                   &MazeProblemGeneralOptions::winningPosition);

    // Losing position
    parser->addOption<VectorFloat>("initialBeliefOptions", "losingPosition",
                                   &MazeProblemGeneralOptions::losingPosition);

    /*** Positions of rocks ***/
    parser->addOption<std::vector<VectorFloat>>(
        "transitionOptions", "rockPositions",
        &MazeProblemGeneralOptions::rockPositions);

    /*** Transition Plugin options ***/
    /*** Reward Plugin options ***/
    parser->addOption<>("transitionOptions", "pCorrectDirection",
                        &MazeProblemGeneralOptions::pCorrectDirection);

    parser->addOption<FloatType>(
        "rewardPluginOptions", "winningStateReward",
        &MazeProblemGeneralOptions::winningStateReward);

    parser->addOption<FloatType>(
        "rewardPluginOptions", "losingStatePenalty",
        &MazeProblemGeneralOptions::losingStatePenalty);

    parser->addOption<FloatType>("rewardPluginOptions", "stepPenalty",
                                 &MazeProblemGeneralOptions::stepPenalty);
  }
};

} // namespace oppt

#endif
