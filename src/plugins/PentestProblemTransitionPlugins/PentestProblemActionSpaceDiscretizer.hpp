#ifndef _SKD_ACTION_SPACE_DISCRETIZER_
#define _SKD_ACTION_SPACE_DISCRETIZER_
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "oppt/robotHeaders/ActionSpaceDiscretizer.hpp"

namespace oppt {

struct ActionSpaceDiscretizerParams {
  int machineIdx;
  int actionIdx;
  int osStatesInfo;
};

ActionSpaceDiscretizerParams
getDiscreteAction(VectorFloat action, int nTestActions, int nMachines) {

  if ((int)action[0] == nMachines) {
    return {.actionIdx = NO_ACTION};
  }

  return {.machineIdx = (int)action[0],
          .actionIdx = (int)action[1],
          .osStatesInfo = (int)action[2]};
}

class PentestProblemActionSpaceDiscretizer : public ActionSpaceDiscretizer {
private:
  int nMachines;
  int nTestActions;
  int nOsStates;

public:
  PentestProblemActionSpaceDiscretizer(ActionSpaceSharedPtr &actionSpace,
                                       int n_machines, int n_test_actions,
                                       int n_os_states)
      : ActionSpaceDiscretizer(actionSpace) {
    // LOGGING("Custom Pentest Action Space Discretizer");
    this->nMachines = n_machines;
    this->nTestActions = n_test_actions;
    this->nOsStates = n_os_states;
  }

  virtual ~PentestProblemActionSpaceDiscretizer() {}

  virtual std::vector<ActionSharedPtr>
  getAllActionsInOrder(const unsigned int &numStepsPerDimension) const {
    std::vector<ActionSharedPtr> allActionsOrdered_;
    long code = 0;
    VectorFloat currAction = {};

    for (int machineIdx = 0; machineIdx < nMachines; machineIdx++) {

      // TEST_ACTIONS
      for (const int test_action : TEST_ACTIONS::All) {
        currAction = {(double)machineIdx, (double)test_action,
                      -1}; // {setDiscreteAction(ap)};
        ActionSharedPtr test_action_ptr(new DiscreteVectorAction(currAction));
        test_action_ptr->as<DiscreteVectorAction>()->setBinNumber(code);
        code++;
        allActionsOrdered_.push_back(test_action_ptr);
      }

      // HACK_ACTIONS
      for (const int hack_action : HACK_ACTIONS::All) {
        for (int os_state : OS_STATES_INFO::All) {
          currAction = {(double)machineIdx, (double)hack_action,
                        (double)os_state}; // {setDiscreteAction(ap)};
          ActionSharedPtr hack_action_ptr(new DiscreteVectorAction(currAction));
          hack_action_ptr->as<DiscreteVectorAction>()->setBinNumber(code);
          code++;
          allActionsOrdered_.push_back(hack_action_ptr);
        }
      }
    }

    // NO_ACTION
    ActionSharedPtr hack_action_ptr(
        new DiscreteVectorAction({(double)nMachines}));
    hack_action_ptr->as<DiscreteVectorAction>()->setBinNumber(code);
    code++;
    allActionsOrdered_.push_back(hack_action_ptr);

    // Print size of action space
    std::cout << "SIZE OF THE ACTION SPACE IS " << allActionsOrdered_.size()
              << std::endl;
    // getchar();

    // Print out list of actions to verify correctness
    // // Print actions
    std::cout << "PRINTING ACTION SPACE " << std::endl;
    for (auto actions : allActionsOrdered_) {
      actions->print(cout);
      std::cout << std::endl;
    }

    // getchar();

    return allActionsOrdered_;
  }
};
} // namespace oppt
#endif
