#ifndef _SKD_ACTION_SPACE_DISCRETIZER_
#define _SKD_ACTION_SPACE_DISCRETIZER_
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "oppt/robotHeaders/ActionSpaceDiscretizer.hpp"

namespace oppt {

struct ActionSpaceDiscretizerParams {
  int machineIdx;
  int actionIdx;
  int osStatesInfo;
};

ActionSpaceDiscretizerParams getDiscreteAction(float discreteAction, int nTestActions, int nOsStates) {
  int discreteActionInt = (int)discreteAction;
  int machineIdx = discreteActionInt / (nTestActions + nOsStates);
  int actionType = discreteActionInt % (nTestActions + nOsStates);
  ActionSpaceDiscretizerParams ap = {
      .machineIdx = machineIdx,
      .actionIdx = actionType <= nTestActions
                       ? actionType
                       : HACK_ACTIONS::Type::EXPLOIT_MACHINE,
      .osStatesInfo = std::max(actionType - nTestActions, 0)};

  return ap;
}

class PentestProblemActionSpaceDiscretizer : public ActionSpaceDiscretizer {
private:
  int nMachines;
  int nTestActions;
  int nOsStates;

public:
  float
  setDiscreteAction(const ActionSpaceDiscretizerParams &actionParams) const {
    // NOTE: Int to float conversation here
    return (nTestActions + nOsStates) * actionParams.machineIdx +
           actionParams.actionIdx + actionParams.osStatesInfo;
  }
  PentestProblemActionSpaceDiscretizer(ActionSpaceSharedPtr &actionSpace,
                                       int n_machines, int n_test_actions,
                                       int n_os_states)
      : ActionSpaceDiscretizer(actionSpace) {
    // LOGGING("Custom Pentest Action Space Discretizer");
    this->nMachines = n_machines;
    this->nTestActions = n_test_actions;
    this->nOsStates = n_os_states;
  }

  virtual ~PentestProblemActionSpaceDiscretizer() {}

  virtual std::vector<ActionSharedPtr>
  getAllActionsInOrder(const unsigned int &numStepsPerDimension) const {
    std::vector<ActionSharedPtr> allActionsOrdered_;
    long code = 0;
    VectorFloat currAction = {};

    for (int machineIdx = 0; machineIdx < nMachines; machineIdx++) {

      // TEST_ACTIONS
      for (const int test_action : TEST_ACTIONS::All) {
        ActionSpaceDiscretizerParams ap = {.machineIdx = machineIdx,
                                           .actionIdx = test_action,
                                           .osStatesInfo = 0};
        currAction = {setDiscreteAction(ap)};
        ActionSharedPtr test_action_ptr(new DiscreteVectorAction(currAction));
        test_action_ptr->as<DiscreteVectorAction>()->setBinNumber(code);
        code++;
        allActionsOrdered_.push_back(test_action_ptr);
      }

      // HACK_ACTIONS
      for (const int hack_action : HACK_ACTIONS::All) {
        for (int os_state : OS_STATES_INFO::All) {
          ActionSpaceDiscretizerParams ap = {.machineIdx = machineIdx,
                                             .actionIdx = hack_action,
                                             .osStatesInfo = os_state};
          currAction = {setDiscreteAction(ap)};
          ActionSharedPtr hack_action_ptr(new DiscreteVectorAction(currAction));
          hack_action_ptr->as<DiscreteVectorAction>()->setBinNumber(code);
          code++;
          allActionsOrdered_.push_back(hack_action_ptr);
        }
      }
    }
    // Print size of action space
    std::cout << "SIZE OF THE ACTION SPACE IS " << allActionsOrdered_.size()
              << std::endl;
    getchar();

    // Print out list of actions to verify correctness
    // // Print actions
    std::cout << "PRINTING ACTION SPACE " << std::endl;
    for (auto actions : allActionsOrdered_) {
      actions->print(cout);
      std::cout << std::endl;
    }

    getchar();

    return allActionsOrdered_;
  }
};
} // namespace oppt
#endif
