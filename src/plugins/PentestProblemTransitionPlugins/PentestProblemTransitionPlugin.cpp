/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License published by the Free Software Foundation,
 * either version 2 of the License, or (at your option) any later version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with OPPT.
 * If not, see http://www.gnu.org/licenses/.
 */
#include "oppt/plugin/Plugin.hpp"
#include "oppt/opptCore/Distribution.hpp"
#include "oppt/gazeboInterface/GazeboInterface.hpp"
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "PentestProblemActionSpaceDiscretizer.hpp"
#include <boost/timer.hpp>
#include "oppt/opptCore/CollisionObject.hpp"
#include "oppt/opptCore/CollisionRequest.hpp"
#include <random>
#include <chrono>


using std::cout;
using std::endl;


namespace oppt
{
class PentestProblemTransitionPlugin : public TransitionPlugin {
public:
  PentestProblemTransitionPlugin() : TransitionPlugin() {}

  virtual ~PentestProblemTransitionPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    // Parse options files
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ = static_cast<PentestProblemGeneralOptions *>(options_.get());

    // Overwrite action space with custom one for individual actions
    auto actionSpace = robotEnvironment_->getRobot()->getActionSpace();

    std::shared_ptr<ActionSpaceDiscretizer> pentestActionSpaceDiscretizer(
        new PentestProblemActionSpaceDiscretizer(actionSpace));
    actionSpace->setActionSpaceDiscretizer(pentestActionSpaceDiscretizer);

    return true;
  }

    virtual PropagationResultSharedPtr propagateState(const PropagationRequest* propagationRequest) const override {

      // NOTE: Generate random moves to somehow always move.. could fix
      // nextState == prevState case in reward plugin
      int appliedAction;

      // Copy information from propagationRequest to propagationResult
      PropagationResultSharedPtr propagationResult(new PropagationResult());
      propagationResult->previousState = propagationRequest->currentState.get();
      propagationResult->action = propagationRequest->action;

      // Extract information from propagationRequest as vectors
      VectorFloat actionApplied =
          propagationRequest->action->as<VectorAction>()->asVector();
      VectorFloat stateVector =
          propagationRequest->currentState->as<VectorState>()->asVector();
      VectorFloat nDims = generalOptions_->pentestDims;

      // Initialize the next state to be the same as the previous state by
      // default
      VectorFloat resultingState(stateVector);

      unsigned seed1 =
          std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator(seed1);
      std::uniform_real_distribution<double> distribution(0, 1);

      // Pack it into the oppt structures
      FloatType pCorrectDirection = (FloatType)distribution(generator);
      int temp = static_cast<int>(actionApplied[PENTEST_ACTIONS_INFO::PENTEST_ACTION_INDEX]);
      // Change according to sample
      if (pCorrectDirection < 0.8) {
        // Init the state with expected direction to go
        appliedAction = static_cast<int>(
            actionApplied[PENTEST_ACTIONS_INFO::PENTEST_ACTION_INDEX]);
        } else if (pCorrectDirection < 0.9) {
          // Init the state with pentest right normal to expected direction
          appliedAction = positive_modulo(temp + 1, 4);
        } else {
          // Init the state with pentest left normal to expected direction
          appliedAction = positive_modulo(temp - 1, 4);
        }

        switch (appliedAction) {
        case PENTEST_PROBLEM_ACTIONS::MOVE_LEFT:
          if (stateVector[PENTEST_STATES_INFO::AGENT_X_INDEX] > 1) {
            resultingState[PENTEST_STATES_INFO::AGENT_X_INDEX] -= 1;
          }
          break;
        case PENTEST_PROBLEM_ACTIONS::MOVE_UP:
          if (stateVector[PENTEST_STATES_INFO::AGENT_Y_INDEX] <
              nDims[PENTEST_STATES_INFO::AGENT_Y_INDEX]) {
            resultingState[PENTEST_STATES_INFO::AGENT_Y_INDEX] += 1;
          }
          break;
        case PENTEST_PROBLEM_ACTIONS::MOVE_RIGHT:
          if (stateVector[PENTEST_STATES_INFO::AGENT_X_INDEX] <
              nDims[PENTEST_STATES_INFO::AGENT_X_INDEX]) {
            resultingState[PENTEST_STATES_INFO::AGENT_X_INDEX] += 1;
          }
          break;
        case PENTEST_PROBLEM_ACTIONS::MOVE_DOWN:
          if (stateVector[PENTEST_STATES_INFO::AGENT_Y_INDEX] > 1) {
            resultingState[PENTEST_STATES_INFO::AGENT_Y_INDEX] -= 1;
          }
          break;
        default:
          break;
        }

        for (VectorFloat rockPos: generalOptions_ -> rockPositions) {
            if (resultingState == rockPos) {
                resultingState = stateVector; // Stay in the same position
                break;
            }
        }

        // Create a robotState object from resulting state
        RobotStateSharedPtr nextRobotState =
            std::make_shared<oppt::VectorState>(resultingState);
        propagationResult->nextState = nextRobotState;

        return propagationResult;
    }

    virtual Distribution<FloatType> *const
    getErrorDistribution() const override {
      return errorDistribution_.get();
    }

  private:
    std::unique_ptr<Distribution<FloatType>> errorDistribution_;

    // General options variables
    PentestProblemGeneralOptions *generalOptions_;

    std::unordered_map<std::string, gazebo::physics::Link *> linkMapTrans_;
    // Unorder map collision Objects associated with each link
    std::unordered_map<std::string, OpptCollisionObject *> collisionLinkMap_;

    // https://stackoverflow.com/a/14997413
    inline int positive_modulo(const int i, const int n) const { return (i % n + n) % n; }
};

OPPT_REGISTER_TRANSITION_PLUGIN(PentestProblemTransitionPlugin)

}
