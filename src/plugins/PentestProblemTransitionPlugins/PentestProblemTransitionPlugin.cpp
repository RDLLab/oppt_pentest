/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#include "../PentestProblemUtils/PentestProblemGeneralUtils.hpp"
#include "PentestProblemActionSpaceDiscretizer.hpp"
#include "oppt/gazeboInterface/GazeboInterface.hpp"
#include "oppt/opptCore/CollisionObject.hpp"
#include "oppt/opptCore/CollisionRequest.hpp"
#include "oppt/opptCore/Distribution.hpp"
#include "oppt/plugin/Plugin.hpp"
#include <boost/timer.hpp>
#include <chrono>
#include <random>

using std::cout;
using std::endl;

std::default_random_engine generator(65537);

namespace oppt {
class PentestProblemTransitionPlugin : public TransitionPlugin {
public:
  PentestProblemTransitionPlugin() : TransitionPlugin() {}

  virtual ~PentestProblemTransitionPlugin() = default;

  virtual bool load(const std::string &optionsFile) override {
    // Parse options files
    parseOptions_<PentestProblemGeneralOptions>(optionsFile);
    generalOptions_ =
        static_cast<PentestProblemGeneralOptions *>(options_.get());

    // Overwrite action space with custom one for individual actions
    auto actionSpace = robotEnvironment_->getRobot()->getActionSpace();

    std::shared_ptr<ActionSpaceDiscretizer> pentestActionSpaceDiscretizer(
        new PentestProblemActionSpaceDiscretizer(
            actionSpace, generalOptions_->nMachines, TEST_ACTIONS::size,
            OS_STATES_INFO::size));
    actionSpace->setActionSpaceDiscretizer(pentestActionSpaceDiscretizer);

    return true;
  }

  virtual PropagationResultSharedPtr
  propagateState(const PropagationRequest *propagationRequest) const override {

    // Copy information from propagationRequest to propagationResult
    PropagationResultSharedPtr propagationResult(new PropagationResult());
    propagationResult->previousState = propagationRequest->currentState.get();
    propagationResult->action = propagationRequest->action;

    // Extract information from propagationRequest as vectors
    VectorFloat actionApplied =
        propagationRequest->action->as<VectorAction>()->asVector();
    VectorFloat stateVector =
        propagationRequest->currentState->as<VectorState>()->asVector();

    // Initialize the next state to be the same as the previous state by
    // default
    VectorFloat resultingState = stateVector;

    ActionSpaceDiscretizerParams ap =
        getDiscreteAction(actionApplied, generalOptions_->nMachines);
    int machineStateIdx = generalOptions_->nMachineParams * ap.machineIdx;

    switch (ap.actionIdx) {
    case HACK_ACTIONS::EXPLOIT_MACHINE:

      OS_STATES_INFO::Type currOs =
          (OS_STATES_INFO::Type)stateVector[machineStateIdx];
      PORT_INFO currPort = (PORT_INFO)stateVector[machineStateIdx + 1];
      SERVER_INFO currServer = (SERVER_INFO)stateVector[machineStateIdx + 2];
      HACK_STAT currHackStat = (HACK_STAT)stateVector[machineStateIdx + 3];

      if (currHackStat == NOT_HACKED) {
        // TODO: Add samba
        if (currPort == OPEN_445 && currOs != OS_STATES_INFO::WIN_11 &&
            ap.osStatesInfo == currOs) {
          std::uniform_real_distribution<double> distribution(0, 1);
          // Pack it into the oppt structures
          FloatType pHackSuccess = (FloatType)distribution(generator);
          if (pHackSuccess < generalOptions_->pSuccessfulHack) {
            resultingState[machineStateIdx + 3] = HACKED;
          }
        }
      }
    }

    RobotStateSharedPtr nextRobotState =
        std::make_shared<oppt::VectorState>(resultingState);
    propagationResult->nextState = nextRobotState;

    return propagationResult;
  }

  virtual Distribution<FloatType> *const getErrorDistribution() const override {
    return errorDistribution_.get();
  }

private:
  std::unique_ptr<Distribution<FloatType>> errorDistribution_;

  // General options variables
  PentestProblemGeneralOptions *generalOptions_;

  std::unordered_map<std::string, gazebo::physics::Link *> linkMapTrans_;
  // Unorder map collision Objects associated with each link
  std::unordered_map<std::string, OpptCollisionObject *> collisionLinkMap_;
};

OPPT_REGISTER_TRANSITION_PLUGIN(PentestProblemTransitionPlugin)

} // namespace oppt
