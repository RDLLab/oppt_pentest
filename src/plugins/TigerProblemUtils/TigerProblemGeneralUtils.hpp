/**
 * Copyright 2017
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#ifndef _TIGER_PROBLEM_UTILS_HPP_
#define _TIGER_PROBLEM_UTILS_HPP_
#include "oppt/plugin/PluginOptions.hpp"

namespace oppt {

// DEFINE THE ENCODED VALUE FOR BOTH STATES
enum TIGER_STATES_INFO { TIGER_STATE_INDEX = 0 };
enum TIGER_ACTIONS_INFO { TIGER_ACTION_INDEX = 0 };
enum TIGER_STATES { TIGER_LEFT = 0, TIGER_RIGHT = 1 };
enum TIGER_PROBLEM_ACTIONS { OPEN_LEFT = 0, OPEN_RIGHT = 1, LISTEN = 2 };

// DEFINE THE ENCODED VALUE FOR ACTIONS
enum MAZE_STATES_INFO { AGENT_X_INDEX = 0, AGENT_Y_INDEX = 1 };
enum MAZE_ACTIONS_INFO { MAZE_ACTION_INDEX = 0 };
// enum MAZE_STATES { MAZE_STATES = 0 };
enum MAZE_PROBLEM_ACTIONS {
  MOVE_LEFT = 0,
  MOVE_UP = 1,
  MOVE_RIGHT = 2,
  MOVE_DOWN = 3
};

// Options object to parse information from configuration file
class TigerProblemGeneralOptions : public PluginOptions {
public:
  TigerProblemGeneralOptions() = default;

  virtual ~TigerProblemGeneralOptions() = default;

  // Initial belief variables
  VectorFloat upperBound;
  VectorFloat lowerBound;

  // Transition variables
  FloatType observationNoise = 0.0;
  // VectorUInt actionSpaceDiscretization;

  // Reward variables
  FloatType correctGuessReward = 0.0;
  FloatType wrongGuessPenalty = 0.0;
  FloatType stepPenalty = 0.0;

  static std::unique_ptr<options::OptionParser> makeParser() {
    std::unique_ptr<options::OptionParser> parser = PluginOptions::makeParser();
    addGeneralPluginOptions(parser.get());
    return std::move(parser);
  }

  // Add the transition plugin options
  static void addGeneralPluginOptions(options::OptionParser *parser) {

    /*** Initial belief options ***/
    // Lower starting bound
    parser->addOption<VectorFloat>("initialBeliefOptions", "lowerBound",
                                   &TigerProblemGeneralOptions::lowerBound);
    // Upper starting bound
    parser->addOption<VectorFloat>("initialBeliefOptions", "upperBound",
                                   &TigerProblemGeneralOptions::upperBound);

    parser->addOption<FloatType>("observationPluginOptions", "observationNoise",
                                 &TigerProblemGeneralOptions::observationNoise);

    /*** Reward Plugin options ***/
    parser->addOption<FloatType>(
        "rewardPluginOptions", "correctGuessReward",
        &TigerProblemGeneralOptions::correctGuessReward);

    parser->addOption<FloatType>(
        "rewardPluginOptions", "wrongGuessPenalty",
        &TigerProblemGeneralOptions::wrongGuessPenalty);

    parser->addOption<FloatType>("rewardPluginOptions", "stepPenalty",
                                 &TigerProblemGeneralOptions::stepPenalty);
  }
};

// Options object to parse information from configuration file
class MazeProblemGeneralOptions : public PluginOptions {
public:
  MazeProblemGeneralOptions() = default;

  virtual ~MazeProblemGeneralOptions() = default;

  // Initial belief variables
  VectorFloat startPosition;
  VectorFloat winningPosition;
  VectorFloat losingPosition;

  // Reward variables
  FloatType winningStateReward = 0.0;
  FloatType losingStatePenalty = 0.0;
  FloatType stepPenalty = 0.0;
  std::vector<VectorFloat> rockPositions = {};

  // Transition variables

  // The probability of going to the correct direction, else it is distributed
  // equally going to the normal directions
  FloatType pCorrectDirection = 0.0;

  static std::unique_ptr<options::OptionParser> makeParser() {
    std::unique_ptr<options::OptionParser> parser = PluginOptions::makeParser();
    addGeneralPluginOptions(parser.get());
    return std::move(parser);
  }

  // Add the general plugin options
  static void addGeneralPluginOptions(options::OptionParser *parser) {

    /*** Initial belief options ***/
    // Starting Position
    parser->addOption<VectorFloat>("initialBeliefOptions", "startPosition",
                                   &MazeProblemGeneralOptions::startPosition);
    // Winning Position
    parser->addOption<VectorFloat>("initialBeliefOptions", "winningPosition",
                                   &MazeProblemGeneralOptions::winningPosition);

    // Losing position
    parser->addOption<VectorFloat>("initialBeliefOptions", "losingPosition",
                                   &MazeProblemGeneralOptions::losingPosition);

    /*** Positions of rocks ***/
    parser->addOption<std::vector<VectorFloat>>("transitionOptions", "rockPositions",
                                 &MazeProblemGeneralOptions::rockPositions);

    /*** Transition Plugin options ***/
    /*** Reward Plugin options ***/
    parser->addOption<>("transitionOptions", "pCorrectDirection",
                                 &MazeProblemGeneralOptions::pCorrectDirection);

    parser->addOption<FloatType>(
        "rewardPluginOptions", "winningStateReward",
        &MazeProblemGeneralOptions::winningStateReward);

    parser->addOption<FloatType>(
        "rewardPluginOptions", "losingStatePenalty",
        &MazeProblemGeneralOptions::losingStatePenalty);

    parser->addOption<FloatType>("rewardPluginOptions", "stepPenalty",
                                 &MazeProblemGeneralOptions::stepPenalty);
  }
};

} // namespace oppt

#endif
