/**
 * Copyright 2022
 *
 * This file is part of On-line POMDP Planning Toolkit (OPPT).
 * OPPT is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * OPPT is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OPPT. If not, see http://www.gnu.org/licenses/.
 */
#ifndef _PENTEST_PROBLEM_UTILS_HPP_
#define _PENTEST_PROBLEM_UTILS_HPP_
#include "oppt/plugin/PluginOptions.hpp"

namespace oppt {
namespace OS_STATES_INFO {
enum Type { WIN_7 = 0, WIN_8 = 1, WIN_10 = 2, WIN_11 = 3 };
static const std::vector<Type> All = {WIN_7, WIN_8, WIN_10, WIN_11};
static const int size = All.size();
} // namespace OS_STATES_INFO
enum PORT_INFO { CLOSED_PORT = 0, OPEN_445 = 1 };
enum SERVER_INFO { NO_SERVER = 0, OPEN_SAMBA_445 = 1 };
enum HACK_STAT { NOT_HACKED = 0, HACKED = 1 };

struct MachineState {
  OS_STATES_INFO::Type os_states_info;
  PORT_INFO port_info;
  SERVER_INFO server_info;
  HACK_STAT hack_stat;
};

//TEST_ACTIONS::NO_ACTION Flattened version of machine states (4 * n_machines)
typedef VectorFloat MachineStates;


namespace TEST_ACTIONS {
enum Type { NO_ACTION = 0, DETECT_OS = 1, PROBE_P445 = 2 };
static const std::vector<Type> All = {NO_ACTION, DETECT_OS, PROBE_P445};
static const int size = All.size();
} // namespace TEST_ACTIONS

namespace HACK_ACTIONS {
enum Type { EXPLOIT_MACHINE = 3 };
static const std::vector<Type> All = {EXPLOIT_MACHINE};
static const int size = All.size();
} // namespace HACK_ACTIONS

union PENTEST_ACTIONS_TYPE {
  TEST_ACTIONS::Type test;
  HACK_ACTIONS::Type hack;
};

struct PENTEST_PROBLEM_ACTION {
  int machineIdx;
  PENTEST_ACTIONS_TYPE pentestActionType;
  OS_STATES_INFO::Type os_state;
};

enum PENTEST_OBSERVATIONS {
  WIN_OLD = 0,
  WIN_NEW = 1,
  OPEN_PORT_OBS = 2,
  CLOSED_PORT_OBS = 3,
  NO_AGENT = 4,
  AGENT_INSTALLED = 5,
};

// Options object to parse information from configuration file
class PentestProblemGeneralOptions : public PluginOptions {
public:
  PentestProblemGeneralOptions() = default;

  virtual ~PentestProblemGeneralOptions() = default;

  int nMachineParams;

  // Initial belief varaibles
  std::vector<VectorFloat> inputMachineStates;
  int nMachines;
  // TODO: Implement randomization
  bool randomizeInitStates = false;

  // Transition variables
  FloatType pSuccessfulHack = 0.0;
  FloatType pSuccessOpenPortNoise = 0.0;

  // Observation variables
  FloatType observationNoise = 0.0;

  // Reward variables
  FloatType hackReward = 0.0;
  FloatType stepPenalty = 0.0;
  FloatType failedHackPenalty = 0.0;

  static std::unique_ptr<options::OptionParser> makeParser() {
    std::unique_ptr<options::OptionParser> parser = PluginOptions::makeParser();
    addGeneralPluginOptions(parser.get());
    return std::move(parser);
  }

  // Add the general plugin options
  static void addGeneralPluginOptions(options::OptionParser *parser) {
    parser->addOption<int>("generalOptions", "nMachineParams",
                           &PentestProblemGeneralOptions::nMachineParams);

    /*** Initial belief options ***/
    parser->addOption<int>("initialBeliefOptions", "nMachines",
                           &PentestProblemGeneralOptions::nMachines);

    parser->addOption<bool>("initialBeliefOptions", "randomizeInitStates",
                            &PentestProblemGeneralOptions::randomizeInitStates);

    parser->addOption<std::vector<VectorFloat>>(
        "initialBeliefOptions", "inputMachineStates",
        &PentestProblemGeneralOptions::inputMachineStates);
    /*** Transition plugin options ***/
    // Probability of hacking a machine successfully if all the guesses are
    // right
    parser->addOption<FloatType>(
        "transitionPluginOptions", "pSuccessfulHack",
        &PentestProblemGeneralOptions::pSuccessfulHack);
    // Probability of getting the right observation of open port if action is
    // probe
    parser->addOption<FloatType>(
        "transitionPluginOptions", "pSuccessOpenPortNoise",
        &PentestProblemGeneralOptions::pSuccessOpenPortNoise);

    /*** Observation plugin options ***/

    // General observation noise - REVIEW: When to implement it
    parser->addOption<FloatType>(
        "observationPluginOptions", "observationNoise",
        &PentestProblemGeneralOptions::observationNoise);

    /*** Reward Plugin options ***/
    parser->addOption<FloatType>("rewardPluginOptions", "hackReward",
                                 &PentestProblemGeneralOptions::hackReward);

    parser->addOption<FloatType>("rewardPluginOptions", "failedHackPenalty",
                                 &PentestProblemGeneralOptions::failedHackPenalty);

    parser->addOption<FloatType>("rewardPluginOptions", "stepPenalty",
                                 &PentestProblemGeneralOptions::stepPenalty);

  }
};

} // namespace oppt

#endif
